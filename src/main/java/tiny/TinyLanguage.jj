/*@bgen(jjtree) Generated By:JJTree: Do not edit this line. TinyLanguage.jj */
/*@egen*/options {
                 
                   
    JDK_VERSION = "13";
}

PARSER_BEGIN(TinyLanguage)
package tiny;
import java.util.HashMap;
public class TinyLanguage/*@bgen(jjtree)*/implements TinyLanguageTreeConstants/*@egen*/ {/*@bgen(jjtree)*/
  protected static JJTTinyLanguageState jjtree = new JJTTinyLanguageState();

/*@egen*/
     static int commands = 0,BExps = 0,AExps = 0;

        // resetting static variables
         static public void Reset() {
            commands = BExps = AExps= 0;
        }
    public static void main(String[] args) throws ParseException{
        TinyLanguage parser = new TinyLanguage(System.in);
        SimpleNode e = parser.Prog();
        //e.dump("");
    }
}

PARSER_END(TinyLanguage)

SKIP : {
    " "/*|"\n"*/|"\r" //I've put \n in the end of Prog just for testing purpses
    //feel free to uncomment it
}

TOKEN : {
    <#DIGIT:["0"-"9"]>
    |<#LETTER:["a"-"f"]>
    |<NUM:(<DIGIT>)+>
    |<FALSE:"ff">
    |<VAR:(<LETTER>)+>
    |<TRUE:"tt">
    |<#PLUS:"+">
    |<#MINUS:"-">
    |<ARTHOPRND:<PLUS>|<MINUS>>
    |<IF:"if">
    |<THEN:"then">
    |<ELSE:"else">
    |<EQUALS:"==">
    |<NOT:"!">
    |<AND:"^">
    |<ASSIGN:":=">
    |<SEMICOLON:";">
    |<WHILE:"while">
    |<DO:"do">
    |<SK:"skip">
    |<OPPAR:"(">
    |<CLOSPAR:")">
}

SimpleNode Prog():
{/*@bgen(jjtree) Prog */
  ASTProg jjtn000 = new ASTProg(JJTPROG);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) Prog */
    try {
/*@egen*/
    Com()("\n"|<EOF>)/*@bgen(jjtree)*/
                     {
                       jjtree.closeNodeScope(jjtn000, true);
                       jjtc000 = false;
                     }
/*@egen*/{return jjtn000;}/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

int Com():
{/*@bgen(jjtree) Com */
  ASTCom jjtn000 = new ASTCom(JJTCOM);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) Com */
    try {
/*@egen*/
//print state after every command
    (SimpleCom()/*{printState();}*/[<SEMICOLON>Com()/*{printState();}*/]
    |CompoundCom()/*{printState();}*/)/*@bgen(jjtree)*/
                                      {
                                        jjtree.closeNodeScope(jjtn000, true);
                                        jjtc000 = false;
                                      }
/*@egen*/{return ++commands;}/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

void SimpleCom():
{/*@bgen(jjtree) SimpleCom */
    ASTSimpleCom jjtn000 = new ASTSimpleCom(JJTSIMPLECOM);
    boolean jjtc000 = true;
    jjtree.openNodeScope(jjtn000);
/*@egen*/
    Token t;
}
{/*@bgen(jjtree) SimpleCom */
    try {
/*@egen*/
    <SK>/*@bgen(jjtree)*/
        {
          jjtree.closeNodeScope(jjtn000, true);
          jjtc000 = false;
        }
/*@egen*/{jjtn000.value = new NodeInfo(token.kind,null);}
    |t=<VAR><ASSIGN>{jjtn000.value = new NodeInfo(token.kind,t.image);}AEXP()/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

void CompoundCom():
{/*@bgen(jjtree) CompoundCom */
    ASTCompoundCom jjtn000 = new ASTCompoundCom(JJTCOMPOUNDCOM);
    boolean jjtc000 = true;
    jjtree.openNodeScope(jjtn000);
/*@egen*/
    Token t;
}
{/*@bgen(jjtree) CompoundCom */
    try {
/*@egen*/
    (t=<IF>BEXP()<THEN>Com()<ELSE>
        |t=<WHILE>BEXP()<DO>)
    Com()/*@bgen(jjtree)*/
         {
           jjtree.closeNodeScope(jjtn000, true);
           jjtc000 = false;
         }
/*@egen*/{jjtn000.value = t.kind;}/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

int AEXP():
{/*@bgen(jjtree) AEXP */
  ASTAEXP jjtn000 = new ASTAEXP(JJTAEXP);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) AEXP */
    try {
/*@egen*/
    (<NUM>
    //if we're parsing a variable within an AEXP, then it is being read not assigned
    |<VAR>)/*@bgen(jjtree)*/
           {
             jjtree.closeNodeScope(jjtn000, true);
             jjtc000 = false;
           }
/*@egen*/{jjtn000.value = new NodeInfo(token.kind, token.image);return ++AExps;}
    |<OPPAR>AEXP()<ARTHOPRND>{jjtn000.value = new NodeInfo(token.kind,token.image);return ++AExps;}AEXP()<CLOSPAR>/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

int BEXP():
{/*@bgen(jjtree) BEXP */
    ASTBEXP jjtn000 = new ASTBEXP(JJTBEXP);
    boolean jjtc000 = true;
    jjtree.openNodeScope(jjtn000);
/*@egen*/
    Token t;
}
{/*@bgen(jjtree) BEXP */
    try {
/*@egen*/
    (t=<TRUE>
    |t=<FALSE>
    |<OPPAR>//the following works good because BEXP is not a subset of AEXP. That is,
        //if the next token is an AEXP then we can be sure (if the statement is
        // syntactically correct) that no BEXP can come after
            (LOOKAHEAD(AEXP())
             AEXP() t=<EQUALS>AEXP()
            |BEXP()t=<AND> BEXP())
     <CLOSPAR>
    |t=<NOT>BEXP())/*@bgen(jjtree)*/
    {
      jjtree.closeNodeScope(jjtn000, true);
      jjtc000 = false;
    }
/*@egen*/
    {jjtn000.value = t.kind;
    return ++BExps;}/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}