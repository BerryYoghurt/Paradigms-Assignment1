PARSER_BEGIN(TinyLanguage)
package tiny;
import java.io.StringReader;
public class TinyLanguage {
    //variables holding number of successfully parsed commands, BExps, and AExps
    static int commands = 0,BExps = 0,AExps = 0;

    // resetting static variables
    static public void Reset() {
            commands = BExps = AExps= 0;
        }
      public static void main(String[] args) throws ParseException{
   String code ="8665*";
              TinyLanguage.ReInit(new StringReader(code));
              TinyLanguage.AEXP();

      }
}
PARSER_END(TinyLanguage)

SKIP : {
    " "/*|"\n"*/|"\r" //I've put \n in the end of Prog just for testing purpses
    //feel free to uncomment it
}

TOKEN : {
    <#DIGIT:["0"-"9"]>
    |<#LETTER:["a"-"f"]>
    |<NUM:(<DIGIT>)+>
    |<FALSE:"ff">
    |<VAR:(<LETTER>)+>
    |<TRUE:"tt">
    |<PLUS:"+">
    |<MINUS:"-">
    |<IF:"if">
    |<THEN:"then">
    |<ELSE:"else">
    |<EQUALS:"==">
    |<NOT:"!">
    |<AND:"^">
    |<ASSIGN:":=">
    |<SEMICOLON:";">
    |<WHILE:"while">
    |<DO:"do">
    |<ENDIF:"endif">
    |<ENDWHILE:"endwhile">
    |<SK:"skip">
    |<OPPAR:"(">
    |<CLOSPAR:")">
}

int Prog():
{}
{
    Com()("\n"|<EOF>){return commands;}
}

int Com():
{}
{
    /*<SK>
    |<VAR><ASSIGN>AEXP()
    |<IF>BEXP()<THEN>Com()<ELSE>Com()
    |<WHILE>BEXP()<DO>Com()
    [<SEMICOLON>Com()]//<EOF>*/
   ( SimpleCom()[<SEMICOLON>Com()] |CompoundCom() ){
            return ++commands;
        }

}

void SimpleCom():
{}
{
    <SK>
    |<VAR><ASSIGN>AEXP()
}

void CompoundCom():
{}
{
    (<IF>BEXP()<THEN>Com()<ELSE>
        |<WHILE>BEXP()<DO>)
    Com()
}

int AEXP():
{}
{
   ( <NUM>
    |<VAR>
    |<OPPAR>AEXP()(<PLUS>|<MINUS>)AEXP()<CLOSPAR>){
        return ++AExps;
}
        }

int BEXP():
{}
{
    (<TRUE>
    |<FALSE>
    |<OPPAR>//the following works good because BEXP is not a subset of AEXP. That is,
        //if the next token is an AEXP then we can be sure (if the statement is
        // syntactically correct) that no BEXP can come after
            (LOOKAHEAD(AEXP()/*<EQUALS>AEXP()<CLOSPAR>(<THEN>|<WHILE>)*/)
            AEXP()<EQUALS>AEXP()
            |BEXP()<AND>BEXP())
     <CLOSPAR>
    |<NOT>BEXP()){
return ++BExps;
}
}
<*> TOKEN : { <UNKNOWN: ~[]> }
